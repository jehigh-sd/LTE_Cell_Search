// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\DACMuxerPrj\DAC_Muxer.v
// Created: 2019-06-19 23:59:29
// 
// Generated by MATLAB 9.6 and HDL Coder 3.14
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: -1
// Target subsystem base rate: -1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DAC_Muxer
// Source Path: DAC_Muxer
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module DAC_Muxer
          #(
            parameter UPPER_WIDTH_0=128,  
            parameter LOWER_WIDTH_0=128,  
            parameter UPPER_WIDTH_1=128,  
            parameter LOWER_WIDTH_1=128,  
			parameter SAMPLESPERCLOCK=16,
			parameter IQMODE=1
           )
          (DACLowerBits0,
           DACUpperBits0,
           DACLowerBits1,
           DACUpperBits1,
		   ValidIn0,
		   ValidIn1,
           DAC,
		   ValidOut);


  input   [LOWER_WIDTH_0-1:0] DACLowerBits0;  
  input   [UPPER_WIDTH_0-1:0] DACUpperBits0;  
  input   [LOWER_WIDTH_1-1:0] DACLowerBits1;  
  input   [UPPER_WIDTH_1-1:0] DACUpperBits1;  
  input   ValidIn0;
  input   ValidIn1;
    
  output  [((LOWER_WIDTH_0-1) + ((SAMPLESPERCLOCK > 8)?(UPPER_WIDTH_0):0) + ((IQMODE==1)?(LOWER_WIDTH_1):0) + ((IQMODE==1)?(UPPER_WIDTH_1):0)):0] DAC;
  output  ValidOut;
  
   genvar n;   
   if (IQMODE==1)
//    if (SAMPLESPERCLOCK<=8)
//        for (n=0;n<SAMPLESPERCLOCK;n=n+1) begin: in_loop
//            assign DAC[((n+1)*32-1):(n*32)] = {DACLowerBits0[((n+1)*16-1):(n*16)], DACLowerBits1[((n+1)*16-1):(n*16)]};
//        end
//    else
        for (n=0;n<SAMPLESPERCLOCK;n=n+1) begin: in_loop
              if (n<8)
                //assign DAC[((n+1)*32-1):(n*32)] = {DACLowerBits0[((n+1)*16-1):(n*16)], DACLowerBits1[((n+1)*16-1):(n*16)]}; //test
				assign DAC[((n+1)*32-1):(n*32)] = {DACLowerBits1[((n+1)*16-1):(n*16)],DACLowerBits0[((n+1)*16-1):(n*16)]}; 
             else
                //assign DAC[((n+1)*32-1):(n*32)] = {DACUpperBits0[((n-8+1)*16-1):((n-8)*16)], DACUpperBits1[((n-8+1)*16-1):((n-8)*16)]};
				assign DAC[((n+1)*32-1):(n*32)] = {DACUpperBits1[((n-8+1)*16-1):((n-8)*16)],DACUpperBits0[((n-8+1)*16-1):((n-8)*16)]};
        end        
        
   else if (SAMPLESPERCLOCK>8 && SAMPLESPERCLOCK<=16 )
       assign DAC = {DACUpperBits0,DACLowerBits0};  // Up to 16 samples per clock (real or IQ) (<=256 bits)
   else 
       assign DAC = {DACUpperBits0};  // 8 samples per clock (<=128 bits) - NON IQ mode   
   assign ValidOut = (ValidIn0 & ValidIn1);

endmodule  // DAC_Muxer

 