-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlDownlinkSyncDemod\LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_SSS_Correlation_Controller.vhd
-- Created: 2022-05-23 17:26:44
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_SSS_Correlation_Controller
-- Source Path: ltehdlDownlinkSyncDemod/Sync Signal Search/SSS Searcher/Max Likelihood SSS/SSS Correlation Controller
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_SSS_Correlation_Controller IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        NCellID2                          :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        validIn                           :   IN    std_logic;
        sampleIndex                       :   OUT   std_logic_vector(5 DOWNTO 0);  -- ufix6
        wrEn                              :   OUT   std_logic;
        rdEn                              :   OUT   std_logic;
        seqNum                            :   OUT   std_logic_vector(9 DOWNTO 0);  -- ufix10
        seqStart                          :   OUT   std_logic;
        seqEnd                            :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_SSS_Correlation_Controller;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_SSS_Correlation_Controller IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in0_unsigned                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL sampleIndex_1                    : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL wrEn_1                           : std_logic;
  SIGNAL rdEn_1                           : std_logic;
  SIGNAL seqNum_1                         : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL seqStart_1                       : std_logic;
  SIGNAL seqEnd_1                         : std_logic;
  SIGNAL reg_validIn                      : std_logic;
  SIGNAL reg_state                        : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL reg_FFTIndex                     : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL reg_sampleIndex                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reg_wrEn                         : std_logic;
  SIGNAL reg_rdEn                         : std_logic;
  SIGNAL reg_seqNum                       : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL reg_seqStart                     : std_logic;
  SIGNAL reg_seqEnd                       : std_logic;
  SIGNAL reg_validIn_next                 : std_logic;
  SIGNAL reg_state_next                   : unsigned(2 DOWNTO 0);  -- ufix3
  SIGNAL reg_FFTIndex_next                : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL reg_sampleIndex_next             : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL reg_wrEn_next                    : std_logic;
  SIGNAL reg_rdEn_next                    : std_logic;
  SIGNAL reg_seqNum_next                  : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL reg_seqStart_next                : std_logic;
  SIGNAL reg_seqEnd_next                  : std_logic;
  SIGNAL sampleIndex_bypass               : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL sampleIndex_last_value           : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL wrEn_2                           : std_logic;
  SIGNAL wrEn_last_value                  : std_logic;
  SIGNAL rdEn_2                           : std_logic;
  SIGNAL rdEn_last_value                  : std_logic;
  SIGNAL seqNum_bypass                    : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL seqNum_last_value                : unsigned(9 DOWNTO 0);  -- ufix10
  SIGNAL seqStart_2                       : std_logic;
  SIGNAL seqStart_last_value              : std_logic;
  SIGNAL seqEnd_2                         : std_logic;
  SIGNAL seqEnd_last_value                : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  in0_unsigned <= unsigned(NCellID2);

  SSS_Correlation_Controller_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        reg_validIn <= '0';
        reg_state <= to_unsigned(16#0#, 3);
        reg_FFTIndex <= to_unsigned(16#00#, 7);
        reg_sampleIndex <= to_unsigned(16#00#, 6);
        reg_wrEn <= '0';
        reg_rdEn <= '0';
        reg_seqNum <= to_unsigned(16#000#, 10);
        reg_seqStart <= '0';
        reg_seqEnd <= '0';
      ELSIF enb_gated = '1' THEN
        reg_validIn <= reg_validIn_next;
        reg_state <= reg_state_next;
        reg_FFTIndex <= reg_FFTIndex_next;
        reg_sampleIndex <= reg_sampleIndex_next;
        reg_wrEn <= reg_wrEn_next;
        reg_rdEn <= reg_rdEn_next;
        reg_seqNum <= reg_seqNum_next;
        reg_seqStart <= reg_seqStart_next;
        reg_seqEnd <= reg_seqEnd_next;
      END IF;
    END IF;
  END PROCESS SSS_Correlation_Controller_process;

  SSS_Correlation_Controller_output : PROCESS (in0_unsigned, reg_FFTIndex, reg_rdEn, reg_sampleIndex, reg_seqEnd, reg_seqNum,
       reg_seqStart, reg_state, reg_validIn, reg_wrEn, validIn)
    VARIABLE next_FFTIndex : unsigned(6 DOWNTO 0);
    VARIABLE next_wrEn : std_logic;
  BEGIN
    ----------------------------------------------------------------------------
    -- Constants
    ----------------------------------------------------------------------------
    -- number of SSS sequences checked for a given PSS
    -- State definitions
    -- State wordlength
    ----------------------------------------------------------------------------
    -- Initialize registers
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    -- Assign outputs
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    -- Update registers
    ----------------------------------------------------------------------------
    -- Initialize next reg values to current values.
    reg_state_next <= reg_state;
    next_FFTIndex := reg_FFTIndex;
    reg_sampleIndex_next <= reg_sampleIndex;
    next_wrEn := reg_wrEn;
    reg_rdEn_next <= reg_rdEn;
    reg_seqNum_next <= reg_seqNum;
    reg_seqStart_next <= reg_seqStart;
    reg_seqEnd_next <= reg_seqEnd;
    -- Register the validIn signal so that edge detection can be used to
    -- establish the start of the 128-point IFFT output.
    -- State machine
    IF (validIn AND ( NOT reg_validIn)) = '1' THEN 
      -- If validIn just went from LOW to HIGH
      reg_state_next <= to_unsigned(16#1#, 3);
      reg_sampleIndex_next <= to_unsigned(16#00#, 6);
      next_FFTIndex := to_unsigned(16#00#, 7);
      next_wrEn := '0';
      reg_rdEn_next <= '0';
      reg_seqNum_next <= to_unsigned(16#000#, 10);
      reg_seqStart_next <= '0';
      reg_seqEnd_next <= '0';
    ELSE 
      -- includes IDLE
      CASE reg_state IS
        WHEN "001" =>
          IF reg_FFTIndex = to_unsigned(16#7F#, 7) THEN 
            reg_state_next <= to_unsigned(16#2#, 3);
            reg_sampleIndex_next <= to_unsigned(16#00#, 6);
            -- Initialize to NCellID
            next_FFTIndex := to_unsigned(16#00#, 7);
            next_wrEn := '0';
            reg_rdEn_next <= '1';
            reg_seqNum_next <= resize(in0_unsigned, 10);
            reg_seqStart_next <= '1';
            reg_seqEnd_next <= '0';
          ELSE 
            next_FFTIndex := reg_FFTIndex + to_unsigned(16#01#, 7);
            -- Reorder SSS subcarrier values on the fly so that they
            -- land in the correct order in RAM.
            IF (next_FFTIndex >= to_unsigned(16#01#, 7)) AND (next_FFTIndex <= to_unsigned(16#1F#, 7)) THEN 
              -- Above DC carrier.
              next_wrEn := '1';
            ELSIF next_FFTIndex >= to_unsigned(16#61#, 7) THEN 
              -- Below DC carrier.
              next_wrEn := '1';
            ELSE 
              -- Somewhere else.
              next_wrEn := '0';
            END IF;
            -- Determine write sample index
            IF next_FFTIndex = to_unsigned(16#01#, 7) THEN 
              reg_sampleIndex_next <= to_unsigned(16#1F#, 6);
            ELSIF next_FFTIndex = to_unsigned(16#61#, 7) THEN 
              reg_sampleIndex_next <= to_unsigned(16#00#, 6);
            ELSIF next_wrEn = '1' THEN 
              reg_sampleIndex_next <= reg_sampleIndex + to_unsigned(16#01#, 6);
            END IF;
            reg_rdEn_next <= '0';
          END IF;
        WHEN "010" =>
          IF reg_sampleIndex = to_unsigned(16#3D#, 6) THEN 
            reg_sampleIndex_next <= to_unsigned(16#00#, 6);
            IF reg_seqNum >= to_unsigned(16#3ED#, 10) THEN 
              -- Finished.
              reg_state_next <= to_unsigned(16#0#, 3);
              reg_seqNum_next <= to_unsigned(16#000#, 10);
              reg_seqStart_next <= '0';
              reg_seqEnd_next <= '0';
            ELSE 
              reg_seqNum_next <= reg_seqNum + to_unsigned(16#003#, 10);
              reg_seqStart_next <= '1';
              reg_seqEnd_next <= '0';
            END IF;
          ELSE 
            reg_sampleIndex_next <= reg_sampleIndex + to_unsigned(16#01#, 6);
            reg_seqStart_next <= '0';
            IF reg_sampleIndex = to_unsigned(16#3C#, 6) THEN 
              reg_seqEnd_next <= '1';
            ELSE 
              reg_seqEnd_next <= '0';
            END IF;
          END IF;
        WHEN OTHERS => 
          NULL;
      END CASE;
    END IF;
    -- Write new values to registers.
    reg_validIn_next <= validIn;
    reg_FFTIndex_next <= next_FFTIndex;
    reg_wrEn_next <= next_wrEn;
    sampleIndex_1 <= reg_sampleIndex;
    wrEn_1 <= reg_wrEn;
    rdEn_1 <= reg_rdEn;
    seqNum_1 <= reg_seqNum;
    seqStart_1 <= reg_seqStart;
    seqEnd_1 <= reg_seqEnd;
  END PROCESS SSS_Correlation_Controller_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        sampleIndex_last_value <= to_unsigned(16#00#, 6);
      ELSIF enb_gated = '1' THEN
        sampleIndex_last_value <= sampleIndex_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  sampleIndex_bypass <= sampleIndex_last_value WHEN stateControl_2 = '0' ELSE
      sampleIndex_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrEn_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        wrEn_last_value <= wrEn_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  wrEn_2 <= wrEn_last_value WHEN stateControl_2 = '0' ELSE
      wrEn_1;

  out2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rdEn_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        rdEn_last_value <= rdEn_2;
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  rdEn_2 <= rdEn_last_value WHEN stateControl_2 = '0' ELSE
      rdEn_1;

  out3_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        seqNum_last_value <= to_unsigned(16#000#, 10);
      ELSIF enb_gated = '1' THEN
        seqNum_last_value <= seqNum_bypass;
      END IF;
    END IF;
  END PROCESS out3_bypass_process;


  
  seqNum_bypass <= seqNum_last_value WHEN stateControl_2 = '0' ELSE
      seqNum_1;

  out4_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        seqStart_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        seqStart_last_value <= seqStart_2;
      END IF;
    END IF;
  END PROCESS out4_bypass_process;


  
  seqStart_2 <= seqStart_last_value WHEN stateControl_2 = '0' ELSE
      seqStart_1;

  out5_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        seqEnd_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        seqEnd_last_value <= seqEnd_2;
      END IF;
    END IF;
  END PROCESS out5_bypass_process;


  
  seqEnd_2 <= seqEnd_last_value WHEN stateControl_2 = '0' ELSE
      seqEnd_1;

  sampleIndex <= std_logic_vector(sampleIndex_bypass);

  wrEn <= wrEn_2;

  rdEn <= rdEn_2;

  seqNum <= std_logic_vector(seqNum_bypass);

  seqStart <= seqStart_2;

  seqEnd <= seqEnd_2;

END rtl;

