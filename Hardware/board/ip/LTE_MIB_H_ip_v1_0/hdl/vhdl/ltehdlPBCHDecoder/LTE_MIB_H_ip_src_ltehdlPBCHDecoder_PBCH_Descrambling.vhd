-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlPBCHDecoder\LTE_MIB_H_ip_src_ltehdlPBCHDecoder_PBCH_Descrambling.vhd
-- Created: 2022-05-23 17:26:45
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlPBCHDecoder_PBCH_Descrambling
-- Source Path: ltehdlPBCHDecoder/PBCH Descrambling
-- Hierarchy Level: 4
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlPBCHDecoder_PBCH_Descrambling IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        goldSeq                           :   IN    std_logic;
        valid_seq                         :   IN    std_logic;
        qpsksymbol_re                     :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En17
        qpsksymbol_im                     :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En17
        deScrambled                       :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En17
        valid                             :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlPBCHDecoder_PBCH_Descrambling;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlPBCHDecoder_PBCH_Descrambling IS

  -- Signals
  SIGNAL Upsample2_muxsel                 : std_logic;  -- ufix1
  SIGNAL qpsksymbol_re_signed             : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL qpsksymbol_im_signed             : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Unary_Minus_cast                 : signed(18 DOWNTO 0);  -- sfix19_En17
  SIGNAL Unary_Minus_cast_1               : signed(18 DOWNTO 0);  -- sfix19_En17
  SIGNAL Unary_Minus_cast_2               : signed(18 DOWNTO 0);  -- sfix19_En17
  SIGNAL Unary_Minus_cast_3               : signed(18 DOWNTO 0);  -- sfix19_En17
  SIGNAL Unary_Minus_out1_re              : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Unary_Minus_out1_im              : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample2_zero                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample2_out1                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample1_muxsel                 : std_logic;  -- ufix1
  SIGNAL Upsample1_zero                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample3_muxsel                 : std_logic;  -- ufix1
  SIGNAL Upsample3_zero                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample3_out1                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample4_muxsel                 : std_logic;  -- ufix1
  SIGNAL Upsample4_zero                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Upsample1_out1                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Sum1_out1                        : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Upsample4_out1                   : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Sum2_out1                        : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Switch_out1                      : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL Delay_out1                       : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL stateControl_3                   : std_logic;
  SIGNAL delayMatch1_reg                  : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_4                   : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL Delay1_out1                      : std_logic;

BEGIN
  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  -- 
  -- Upsample2: Upsample by 2, Sample offset 0 
  Upsample2_cnt_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Upsample2_muxsel <= '1';
      ELSIF enb = '1' THEN
        Upsample2_muxsel <=  NOT Upsample2_muxsel;
      END IF;
    END IF;
  END PROCESS Upsample2_cnt_process;


  qpsksymbol_re_signed <= signed(qpsksymbol_re);

  qpsksymbol_im_signed <= signed(qpsksymbol_im);

  Unary_Minus_cast <= resize(qpsksymbol_re_signed, 19);
  Unary_Minus_cast_1 <=  - (Unary_Minus_cast);
  Unary_Minus_out1_re <= Unary_Minus_cast_1(17 DOWNTO 0);
  Unary_Minus_cast_2 <= resize(qpsksymbol_im_signed, 19);
  Unary_Minus_cast_3 <=  - (Unary_Minus_cast_2);
  Unary_Minus_out1_im <= Unary_Minus_cast_3(17 DOWNTO 0);

  Upsample2_zero <= to_signed(16#00000#, 18);

  
  Upsample2_out1 <= Unary_Minus_out1_re WHEN Upsample2_muxsel = '1' ELSE
      Upsample2_zero;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  -- 
  -- Upsample1: Upsample by 2, Sample offset 1 
  Upsample1_cnt_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Upsample1_muxsel <= '0';
      ELSIF enb = '1' THEN
        Upsample1_muxsel <=  NOT Upsample1_muxsel;
      END IF;
    END IF;
  END PROCESS Upsample1_cnt_process;


  Upsample1_zero <= to_signed(16#00000#, 18);

  -- Free running, Unsigned Counter
  --  initial value   = 1
  --  step value      = 1
  -- 
  -- Upsample3: Upsample by 2, Sample offset 0 
  Upsample3_cnt_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Upsample3_muxsel <= '1';
      ELSIF enb = '1' THEN
        Upsample3_muxsel <=  NOT Upsample3_muxsel;
      END IF;
    END IF;
  END PROCESS Upsample3_cnt_process;


  Upsample3_zero <= to_signed(16#00000#, 18);

  
  Upsample3_out1 <= qpsksymbol_re_signed WHEN Upsample3_muxsel = '1' ELSE
      Upsample3_zero;

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  -- 
  -- Upsample4: Upsample by 2, Sample offset 1 
  Upsample4_cnt_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Upsample4_muxsel <= '0';
      ELSIF enb = '1' THEN
        Upsample4_muxsel <=  NOT Upsample4_muxsel;
      END IF;
    END IF;
  END PROCESS Upsample4_cnt_process;


  Upsample4_zero <= to_signed(16#00000#, 18);

  
  switch_compare_1 <= '1' WHEN goldSeq > '0' ELSE
      '0';

  
  Upsample1_out1 <= Unary_Minus_out1_im WHEN Upsample1_muxsel = '1' ELSE
      Upsample1_zero;

  Sum1_out1 <= Upsample2_out1 + Upsample1_out1;

  
  Upsample4_out1 <= qpsksymbol_im_signed WHEN Upsample4_muxsel = '1' ELSE
      Upsample4_zero;

  Sum2_out1 <= Upsample3_out1 + Upsample4_out1;

  
  Switch_out1 <= Sum1_out1 WHEN switch_compare_1 = '0' ELSE
      Sum2_out1;

  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated = '1' THEN
        Delay_out1 <= Switch_out1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  deScrambled <= std_logic_vector(Delay_out1);

  stateControl_3 <= '1';

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch1_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch1_reg(0) <= stateControl_3;
        delayMatch1_reg(1 TO 41) <= delayMatch1_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  stateControl_4 <= delayMatch1_reg(41);

  enb_gated_1 <= stateControl_4 AND enb;

  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_out1 <= '0';
      ELSIF enb_gated_1 = '1' THEN
        Delay1_out1 <= valid_seq;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  valid <= Delay1_out1;

END rtl;

