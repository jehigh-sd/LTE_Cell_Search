-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlPBCHDecoder\LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Determine_Scaling.vhd
-- Created: 2022-05-23 17:26:45
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Determine_Scaling
-- Source Path: ltehdlPBCHDecoder/BCH Decoder/softBitScalingUnit/Determine Scaling
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.LTE_MIB_H_ip_src_ltehdlPBCHDecoder_ltehdlPBCHDecoder_pac.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Determine_Scaling IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        maxIn                             :   IN    std_logic_vector(18 DOWNTO 0);  -- ufix19
        maxValid                          :   IN    std_logic;
        shiftAmount                       :   OUT   std_logic_vector(4 DOWNTO 0);  -- ufix5
        fineGain                          :   OUT   std_logic_vector(7 DOWNTO 0);  -- ufix8_En7
        scalingValid                      :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Determine_Scaling;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Determine_Scaling IS

  -- Constants
  CONSTANT recipLUT                       : vector_of_unsigned8(0 TO 15) := 
    (to_unsigned(16#F8#, 8), to_unsigned(16#E9#, 8), to_unsigned(16#DC#, 8), to_unsigned(16#D1#, 8),
     to_unsigned(16#C6#, 8), to_unsigned(16#BD#, 8), to_unsigned(16#B4#, 8), to_unsigned(16#AD#, 8),
     to_unsigned(16#A5#, 8), to_unsigned(16#9F#, 8), to_unsigned(16#99#, 8), to_unsigned(16#93#, 8),
     to_unsigned(16#8E#, 8), to_unsigned(16#89#, 8), to_unsigned(16#84#, 8), to_unsigned(16#80#, 8));  -- ufix8 [16]

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in0_unsigned                     : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL shiftAmount_1                    : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL fineGain_1                       : unsigned(7 DOWNTO 0);  -- ufix8_En7
  SIGNAL scalingValid_1                   : std_logic;
  SIGNAL regs_shiftAmount                 : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL regs_fineGain                    : unsigned(7 DOWNTO 0);  -- ufix8_En7
  SIGNAL regs_validOut                    : std_logic;
  SIGNAL regs_shiftAmount_next            : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL regs_fineGain_next               : unsigned(7 DOWNTO 0);  -- ufix8_En7
  SIGNAL regs_validOut_next               : std_logic;
  SIGNAL shiftAmount_bypass               : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL shiftAmount_last_value           : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL fineGain_bypass                  : unsigned(7 DOWNTO 0);  -- ufix8_En7
  SIGNAL fineGain_last_value              : unsigned(7 DOWNTO 0);  -- ufix8_En7
  SIGNAL scalingValid_2                   : std_logic;
  SIGNAL scalingValid_last_value          : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  in0_unsigned <= unsigned(maxIn);

  Determine_Scaling_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        regs_shiftAmount <= to_unsigned(16#00#, 5);
        regs_fineGain <= to_unsigned(16#00#, 8);
        regs_validOut <= '0';
      ELSIF enb_gated = '1' THEN
        regs_shiftAmount <= regs_shiftAmount_next;
        regs_fineGain <= regs_fineGain_next;
        regs_validOut <= regs_validOut_next;
      END IF;
    END IF;
  END PROCESS Determine_Scaling_process;

  Determine_Scaling_output : PROCESS (in0_unsigned, maxValid, regs_fineGain, regs_shiftAmount, regs_validOut)
    VARIABLE kmssb : unsigned(4 DOWNTO 0);
    VARIABLE recipLUTIndex : unsigned(3 DOWNTO 0);
    VARIABLE next_shiftAmount : unsigned(4 DOWNTO 0);
    VARIABLE bit_idx : unsigned(7 DOWNTO 0);
    VARIABLE c : unsigned(18 DOWNTO 0);
    VARIABLE add_temp : vector_of_signed32(0 TO 18);
    VARIABLE cast : unsigned(7 DOWNTO 0);
  BEGIN
    c := to_unsigned(16#00000#, 19);
    recipLUTIndex := to_unsigned(16#0#, 4);
    kmssb := to_unsigned(16#00#, 5);
    bit_idx := to_unsigned(16#00#, 8);
    cast := to_unsigned(16#00#, 8);
    -- Approximates the gain which would need to be applied to maxIn
    -- so that it results in the maximum possible value representable by its
    -- data type. If M is the largest possible value representable by the data
    -- type of maxIn, then the gain, G, is approximately G = M/maxIn.
    -- G is expressed as a left shiftAmount and a fineGain term.
    --------------------------------------------------------------------------
    -- Constants
    --------------------------------------------------------------------------
    -- Compute fine adjustment
    -- Number of bits from max av to use to determine fine adjustment
    -- Create fine gain LUT
    --------------------------------------------------------------------------
    -- Registers
    --------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- Signals (non-registers)
    --------------------------------------------------------------------------
    -- Assign outputs
    --------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- Update registers
    --------------------------------------------------------------------------
    -- Initialize next register values
    next_shiftAmount := regs_shiftAmount;
    regs_fineGain_next <= regs_fineGain;
    IF maxValid = '1' THEN 
      kmssb := to_unsigned(16#01#, 5);
      -- Find the most significant set bit (kmssb)

      FOR k IN 0 TO 18 LOOP
        bit_idx := unsigned(to_signed(k, 32)(7 DOWNTO 0));
        IF in0_unsigned(to_integer(bit_idx)) = '1' THEN 
          add_temp(k) := to_signed(k + 1, 32);
          kmssb := unsigned(add_temp(k)(4 DOWNTO 0));
        END IF;
      END LOOP;

      -- Compute the shift required to make the coarse adjustment
      next_shiftAmount := to_unsigned(16#13#, 5) - kmssb;
      -- Use N bits to the right of kmssb to index the fine gain LUT
      cast := resize(next_shiftAmount, 8);
      c := in0_unsigned sll to_integer(cast);
      recipLUTIndex := c(17 DOWNTO 14);
      regs_fineGain_next <= recipLUT(to_integer(recipLUTIndex));
    END IF;
    -- Update registers
    regs_shiftAmount_next <= next_shiftAmount;
    regs_validOut_next <= maxValid;
    shiftAmount_1 <= regs_shiftAmount;
    fineGain_1 <= regs_fineGain;
    scalingValid_1 <= regs_validOut;
  END PROCESS Determine_Scaling_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        shiftAmount_last_value <= to_unsigned(16#00#, 5);
      ELSIF enb_gated = '1' THEN
        shiftAmount_last_value <= shiftAmount_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  shiftAmount_bypass <= shiftAmount_last_value WHEN stateControl_2 = '0' ELSE
      shiftAmount_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        fineGain_last_value <= to_unsigned(16#00#, 8);
      ELSIF enb_gated = '1' THEN
        fineGain_last_value <= fineGain_bypass;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  fineGain_bypass <= fineGain_last_value WHEN stateControl_2 = '0' ELSE
      fineGain_1;

  out2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        scalingValid_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        scalingValid_last_value <= scalingValid_2;
      END IF;
    END IF;
  END PROCESS out2_bypass_process;


  
  scalingValid_2 <= scalingValid_last_value WHEN stateControl_2 = '0' ELSE
      scalingValid_1;

  shiftAmount <= std_logic_vector(shiftAmount_bypass);

  fineGain <= std_logic_vector(fineGain_bypass);

  scalingValid <= scalingValid_2;

END rtl;

