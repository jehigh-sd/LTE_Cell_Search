-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlPBCHDecoder\LTE_MIB_H_ip_src_ltehdlPBCHDecoder_rateRecovery.vhd
-- Created: 2022-05-23 17:26:45
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlPBCHDecoder_rateRecovery
-- Source Path: ltehdlPBCHDecoder/PBCH Rate Recovery/rateRecovery
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.LTE_MIB_H_ip_src_ltehdlPBCHDecoder_ltehdlPBCHDecoder_pac.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlPBCHDecoder_rateRecovery IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        u1                                :   IN    std_logic_vector(17 DOWNTO 0);  -- ufix18
        enb_1                             :   IN    std_logic;
        y_0                               :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20_En17
        y_1                               :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20_En17
        y_2                               :   OUT   std_logic_vector(19 DOWNTO 0);  -- sfix20_En17
        validOut                          :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlPBCHDecoder_rateRecovery;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlPBCHDecoder_rateRecovery IS

  -- Constants
  CONSTANT nc                             : vector_of_unsigned7(0 TO 39) := 
    (to_unsigned(16#18#, 7), to_unsigned(16#04#, 7), to_unsigned(16#22#, 7), to_unsigned(16#0E#, 7),
     to_unsigned(16#1D#, 7), to_unsigned(16#09#, 7), to_unsigned(16#27#, 7), to_unsigned(16#13#, 7),
     to_unsigned(16#15#, 7), to_unsigned(16#01#, 7), to_unsigned(16#1F#, 7), to_unsigned(16#0B#, 7),
     to_unsigned(16#1A#, 7), to_unsigned(16#06#, 7), to_unsigned(16#24#, 7), to_unsigned(16#10#, 7),
     to_unsigned(16#17#, 7), to_unsigned(16#03#, 7), to_unsigned(16#21#, 7), to_unsigned(16#0D#, 7),
     to_unsigned(16#1C#, 7), to_unsigned(16#08#, 7), to_unsigned(16#26#, 7), to_unsigned(16#12#, 7),
     to_unsigned(16#16#, 7), to_unsigned(16#02#, 7), to_unsigned(16#20#, 7), to_unsigned(16#0C#, 7),
     to_unsigned(16#1B#, 7), to_unsigned(16#07#, 7), to_unsigned(16#25#, 7), to_unsigned(16#11#, 7),
     to_unsigned(16#19#, 7), to_unsigned(16#05#, 7), to_unsigned(16#23#, 7), to_unsigned(16#0F#, 7),
     to_unsigned(16#1E#, 7), to_unsigned(16#0A#, 7), to_unsigned(16#28#, 7), to_unsigned(16#14#, 7));  -- ufix7 [40]

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in0_signed                       : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL y                                : vector_of_signed20(0 TO 2);  -- sfix20_En17 [3]
  SIGNAL validOut_1                       : std_logic;
  SIGNAL dbuffer                          : vector_of_signed20(0 TO 119);  -- sfix20 [120]
  SIGNAL waddr                            : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rIdx                             : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL rCnt                             : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL rateRState                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL readFlag                         : std_logic;
  SIGNAL dbuffer_next                     : vector_of_signed20(0 TO 119);  -- sfix20_En17 [120]
  SIGNAL waddr_next                       : unsigned(8 DOWNTO 0);  -- ufix9
  SIGNAL rIdx_next                        : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL rCnt_next                        : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL rateRState_next                  : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL readFlag_next                    : std_logic;
  SIGNAL y_bypass                         : vector_of_signed20(0 TO 2);  -- sfix20_En17 [3]
  SIGNAL y_last_value                     : vector_of_signed20(0 TO 2);  -- sfix20_En17 [3]
  SIGNAL validOut_2                       : std_logic;
  SIGNAL validOut_last_value              : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  in0_signed <= signed(u1);

  rateRecovery_process : PROCESS (clk)
    VARIABLE t_1 : INTEGER;
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN

        FOR t_1 IN 0 TO 119 LOOP
          dbuffer(t_1) <= to_signed(16#00000#, 20);
        END LOOP;

        waddr <= to_unsigned(16#000#, 9);
        rIdx <= to_unsigned(16#00#, 7);
        rCnt <= to_unsigned(16#00#, 7);
        rateRState <= to_unsigned(16#0#, 2);
        readFlag <= '0';
      ELSIF enb_gated = '1' THEN

        FOR t_0 IN 0 TO 119 LOOP
          dbuffer(t_0) <= dbuffer_next(t_0);
        END LOOP;

        waddr <= waddr_next;
        rIdx <= rIdx_next;
        rCnt <= rCnt_next;
        rateRState <= rateRState_next;
        readFlag <= readFlag_next;
      END IF;
    END IF;
  END PROCESS rateRecovery_process;

  rateRecovery_output : PROCESS (dbuffer, enb_1, in0_signed, rCnt, rIdx, rateRState, readFlag, waddr)
    VARIABLE raddr : vector_of_unsigned7(0 TO 2);
    VARIABLE t : signed(20 DOWNTO 0);
    VARIABLE waddr_temp : unsigned(8 DOWNTO 0);
    VARIABLE rIdx_temp : unsigned(6 DOWNTO 0);
    VARIABLE rCnt_temp : unsigned(6 DOWNTO 0);
    VARIABLE add_cast : signed(20 DOWNTO 0);
    VARIABLE add_cast_0 : signed(20 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : vector_of_signed32(0 TO 2);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 2);
  BEGIN
    t := to_signed(16#000000#, 21);
    add_cast := to_signed(16#000000#, 21);
    add_cast_0 := to_signed(16#000000#, 21);
    sub_cast := to_signed(16#00000000#, 32);
    waddr_temp := waddr;
    rIdx_temp := rIdx;
    rCnt_temp := rCnt;

    FOR t_0 IN 0 TO 119 LOOP
      dbuffer_next(t_0) <= dbuffer(t_0);
    END LOOP;

    rateRState_next <= rateRState;
    readFlag_next <= readFlag;
    --Assuming input is always signed fi type
    -- connecting to Viterbi Decoder

    FOR t_1 IN 0 TO 2 LOOP
      y(t_1) <= to_signed(16#00000#, 20);
    END LOOP;

    validOut_1 <= '0';
    CASE rateRState IS
      WHEN "00" =>
        -- idle state
        IF enb_1 = '1' THEN 
          rateRState_next <= to_unsigned(16#1#, 2);
          waddr_temp := waddr + to_unsigned(16#001#, 9);
          dbuffer_next(119) <= resize(in0_signed, 20);
        END IF;
      WHEN "01" =>
        IF enb_1 = '1' THEN 
          waddr_temp := waddr + to_unsigned(16#001#, 9);
          add_cast := resize(dbuffer(0), 21);
          add_cast_0 := resize(in0_signed, 21);
          t := add_cast + add_cast_0;

          FOR t_3 IN 0 TO 118 LOOP
            dbuffer_next(t_3) <= dbuffer(1 + t_3);
          END LOOP;

          dbuffer_next(119) <= t(19 DOWNTO 0);
          IF waddr_temp = to_unsigned(16#1E0#, 9) THEN 
            waddr_temp := to_unsigned(16#000#, 9);
            rateRState_next <= to_unsigned(16#2#, 2);
            readFlag_next <= '1';
          END IF;
        END IF;
      WHEN "10" =>
        IF readFlag = '1' THEN 
          rIdx_temp := rIdx + to_unsigned(16#01#, 7);
          rCnt_temp := rCnt + to_unsigned(16#01#, 7);
          sub_cast := signed(resize(rIdx_temp, 32));
          raddr(0) := nc(to_integer(sub_cast - 1));
          raddr(1) := raddr(0) + to_unsigned(16#28#, 7);
          raddr(2) := raddr(0) + to_unsigned(16#50#, 7);
          IF rIdx_temp = to_unsigned(16#28#, 7) THEN 
            rIdx_temp := to_unsigned(16#00#, 7);
          END IF;
          IF rCnt_temp = to_unsigned(16#28#, 7) THEN 
            rateRState_next <= to_unsigned(16#0#, 2);
            waddr_temp := to_unsigned(16#000#, 9);
            rIdx_temp := to_unsigned(16#00#, 7);
            rCnt_temp := to_unsigned(16#00#, 7);
            readFlag_next <= '0';
          END IF;

          FOR t_4 IN 0 TO 2 LOOP
            sub_cast_0(t_4) := signed(resize(raddr(t_4), 32));
            y(t_4) <= dbuffer(to_integer(sub_cast_0(t_4) - 1));
            sub_cast_1(t_4) := signed(resize(raddr(t_4), 32));
            dbuffer_next(to_integer(sub_cast_1(t_4) - 1)) <= to_signed(16#00000#, 20);
          END LOOP;

          validOut_1 <= '1';
        END IF;
        --   readFlag = ~readFlag; %read rate control
      WHEN OTHERS => 

        FOR t_2 IN 0 TO 2 LOOP
          y(t_2) <= to_signed(16#00000#, 20);
        END LOOP;

        rateRState_next <= to_unsigned(16#0#, 2);
        waddr_temp := to_unsigned(16#000#, 9);
        rIdx_temp := to_unsigned(16#00#, 7);
    END CASE;
    waddr_next <= waddr_temp;
    rIdx_next <= rIdx_temp;
    rCnt_next <= rCnt_temp;
  END PROCESS rateRecovery_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        y_last_value <= (OTHERS => to_signed(16#00000#, 20));
      ELSIF enb_gated = '1' THEN
        y_last_value <= y_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  y_bypass <= y_last_value WHEN stateControl_2 = '0' ELSE
      y;

  y_0 <= std_logic_vector(y_bypass(0));

  y_1 <= std_logic_vector(y_bypass(1));

  y_2 <= std_logic_vector(y_bypass(2));

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validOut_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        validOut_last_value <= validOut_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  validOut_2 <= validOut_last_value WHEN stateControl_2 = '0' ELSE
      validOut_1;

  validOut <= validOut_2;

END rtl;

