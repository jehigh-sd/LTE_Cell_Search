-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlPBCHDecoder\LTE_MIB_H_ip_src_ltehdlPBCHDecoder_MemoryController.vhd
-- Created: 2022-05-23 17:26:45
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlPBCHDecoder_MemoryController
-- Source Path: ltehdlPBCHDecoder/BCH Decoder/softBitScalingUnit/MemoryController  
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlPBCHDecoder_MemoryController IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        ctrlIn_start                      :   IN    std_logic;
        ctrlIn_end                        :   IN    std_logic;
        ctrlIn_valid                      :   IN    std_logic;
        startReading                      :   IN    std_logic;
        addr                              :   OUT   std_logic_vector(5 DOWNTO 0);  -- ufix6
        writeEn                           :   OUT   std_logic;
        ctrlOut_start                     :   OUT   std_logic;  -- record {boolean,boolean,boolean}
        ctrlOut_end                       :   OUT   std_logic;  -- record {boolean,boolean,boolean}
        ctrlOut_valid                     :   OUT   std_logic  -- record {boolean,boolean,boolean}
        );
END LTE_MIB_H_ip_src_ltehdlPBCHDecoder_MemoryController;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlPBCHDecoder_MemoryController IS

  -- Constants
  CONSTANT nc                             : std_logic_vector(0 TO 2) := 
    ('0', '0', '1');  -- boolean [3]
  CONSTANT nc_0                           : std_logic_vector(0 TO 2) := 
    ('0', '1', '1');  -- boolean [3]
  CONSTANT nc_1_1                         : std_logic_vector(0 TO 2) := 
    ('1', '0', '1');  -- boolean [3]

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL addr_1                           : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL writeEn_1                        : std_logic;
  SIGNAL ctrlOut_start_1                  : std_logic;
  SIGNAL ctrlOut_end_1                    : std_logic;
  SIGNAL ctrlOut_valid_1                  : std_logic;
  SIGNAL regs_state                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL regs_addr                        : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL regs_endAddr                     : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL regs_writeEn                     : std_logic;
  SIGNAL regs_ctrlVec                     : std_logic_vector(0 TO 2);  -- boolean [3]
  SIGNAL regs_not_empty                   : std_logic;
  SIGNAL regs_state_next                  : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL regs_addr_next                   : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL regs_endAddr_next                : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL regs_writeEn_next                : std_logic;
  SIGNAL regs_ctrlVec_next                : std_logic_vector(0 TO 2);  -- boolean [3]
  SIGNAL regs_not_empty_next              : std_logic;
  SIGNAL addr_bypass                      : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL addr_last_value                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL writeEn_2                        : std_logic;
  SIGNAL writeEn_last_value               : std_logic;
  SIGNAL ctrlOut_start_2                  : std_logic;
  SIGNAL ctrlOut_last_value_start         : std_logic;
  SIGNAL ctrlOut_end_2                    : std_logic;
  SIGNAL ctrlOut_last_value_end           : std_logic;
  SIGNAL ctrlOut_valid_2                  : std_logic;
  SIGNAL ctrlOut_last_value_valid         : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  MemoryController_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        regs_not_empty <= '0';
      ELSIF enb_gated = '1' THEN
        regs_state <= regs_state_next;
        regs_addr <= regs_addr_next;
        regs_endAddr <= regs_endAddr_next;
        regs_writeEn <= regs_writeEn_next;

        FOR t_0 IN 0 TO 2 LOOP
          regs_ctrlVec(t_0) <= regs_ctrlVec_next(t_0);
        END LOOP;

        regs_not_empty <= regs_not_empty_next;
      END IF;
    END IF;
  END PROCESS MemoryController_process;

  MemoryController_output : PROCESS (ctrlIn_end, ctrlIn_start, ctrlIn_valid, regs_addr, regs_ctrlVec, regs_endAddr,
       regs_not_empty, regs_state, regs_writeEn, startReading)
    VARIABLE next_state : unsigned(1 DOWNTO 0);
    VARIABLE next_addr : unsigned(5 DOWNTO 0);
    VARIABLE next_endAddr : unsigned(5 DOWNTO 0);
    VARIABLE next_ctrlVec : std_logic_vector(0 TO 2);
    VARIABLE regs_addr_temp : unsigned(5 DOWNTO 0);
    VARIABLE regs_ctrlVec_temp : std_logic_vector(0 TO 2);
  BEGIN
    next_state := regs_state;
    regs_addr_temp := regs_addr;
    next_endAddr := regs_endAddr;
    writeEn_1 <= regs_writeEn;

    FOR t_10 IN 0 TO 2 LOOP
      regs_ctrlVec_temp(t_10) := regs_ctrlVec(t_10);
    END LOOP;

    regs_not_empty_next <= regs_not_empty;
    IF ( NOT regs_not_empty) = '1' THEN 
      next_state := to_unsigned(16#0#, 2);
      regs_addr_temp := to_unsigned(16#00#, 6);
      next_endAddr := to_unsigned(16#00#, 6);
      writeEn_1 <= '0';

      FOR t_0 IN 0 TO 2 LOOP
        regs_ctrlVec_temp(t_0) := '0';
      END LOOP;

      regs_not_empty_next <= '1';
    END IF;
    -- Assign outputs
    ctrlOut_start_1 <= regs_ctrlVec_temp(0);
    ctrlOut_end_1 <= regs_ctrlVec_temp(1);
    ctrlOut_valid_1 <= regs_ctrlVec_temp(2);
    -- Update registers
    next_addr := regs_addr_temp;
    IF (ctrlIn_valid AND ctrlIn_start) = '1' THEN 
      next_state := to_unsigned(16#1#, 2);
      next_addr := to_unsigned(16#00#, 6);
      next_endAddr := to_unsigned(16#00#, 6);
      regs_writeEn_next <= '1';

      FOR t_2 IN 0 TO 2 LOOP
        next_ctrlVec(t_2) := '0';
      END LOOP;

    ELSE 
      CASE next_state IS
        WHEN "01" =>
          IF ctrlIn_valid = '1' THEN 
            IF ctrlIn_end = '1' THEN 
              next_state := to_unsigned(16#2#, 2);
            END IF;
            next_addr := regs_addr_temp + to_unsigned(16#01#, 6);
            regs_writeEn_next <= '1';
          ELSE 
            regs_writeEn_next <= '0';
          END IF;

          FOR t_1 IN 0 TO 2 LOOP
            next_ctrlVec(t_1) := '0';
          END LOOP;

        WHEN "10" =>
          IF startReading = '1' THEN 
            next_state := to_unsigned(16#3#, 2);
            next_addr := to_unsigned(16#00#, 6);
            next_endAddr := regs_addr_temp;
            regs_writeEn_next <= '0';

            FOR t_7 IN 0 TO 2 LOOP
              next_ctrlVec(t_7) := nc_1_1(t_7);
            END LOOP;

          ELSE 
            next_state := to_unsigned(16#2#, 2);
            next_endAddr := regs_addr_temp;
            regs_writeEn_next <= '0';

            FOR t_6 IN 0 TO 2 LOOP
              next_ctrlVec(t_6) := '0';
            END LOOP;

          END IF;
        WHEN "11" =>
          IF regs_addr_temp >= next_endAddr THEN 
            next_state := to_unsigned(16#0#, 2);
            next_addr := to_unsigned(16#00#, 6);
            next_endAddr := to_unsigned(16#00#, 6);
            regs_writeEn_next <= '0';

            FOR t_8 IN 0 TO 2 LOOP
              next_ctrlVec(t_8) := '0';
            END LOOP;

          ELSE 
            next_addr := regs_addr_temp + to_unsigned(16#01#, 6);
            regs_writeEn_next <= '0';
            IF next_addr = next_endAddr THEN 

              FOR t_4 IN 0 TO 2 LOOP
                next_ctrlVec(t_4) := nc_0(t_4);
              END LOOP;

            ELSE 

              FOR t_3 IN 0 TO 2 LOOP
                next_ctrlVec(t_3) := nc(t_3);
              END LOOP;

            END IF;
          END IF;
        WHEN OTHERS => 
          -- includes IDLE state
          next_state := to_unsigned(16#0#, 2);
          next_addr := to_unsigned(16#00#, 6);
          next_endAddr := to_unsigned(16#00#, 6);
          regs_writeEn_next <= '0';

          FOR t_5 IN 0 TO 2 LOOP
            next_ctrlVec(t_5) := '0';
          END LOOP;

      END CASE;
    END IF;

    FOR t_9 IN 0 TO 2 LOOP
      regs_ctrlVec_next(t_9) <= next_ctrlVec(t_9);
    END LOOP;

    addr_1 <= regs_addr_temp;
    regs_state_next <= next_state;
    regs_addr_next <= next_addr;
    regs_endAddr_next <= next_endAddr;
  END PROCESS MemoryController_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        addr_last_value <= to_unsigned(16#00#, 6);
      ELSIF enb_gated = '1' THEN
        addr_last_value <= addr_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  addr_bypass <= addr_last_value WHEN stateControl_2 = '0' ELSE
      addr_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        writeEn_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        writeEn_last_value <= writeEn_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  writeEn_2 <= writeEn_last_value WHEN stateControl_2 = '0' ELSE
      writeEn_1;

  c_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        ctrlOut_last_value_start <= '0';
      ELSIF enb_gated = '1' THEN
        ctrlOut_last_value_start <= ctrlOut_start_2;
      END IF;
    END IF;
  END PROCESS c_process;


  
  ctrlOut_start_2 <= ctrlOut_last_value_start WHEN stateControl_2 = '0' ELSE
      ctrlOut_start_1;

  c_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        ctrlOut_last_value_end <= '0';
      ELSIF enb_gated = '1' THEN
        ctrlOut_last_value_end <= ctrlOut_end_2;
      END IF;
    END IF;
  END PROCESS c_1_process;


  
  ctrlOut_end_2 <= ctrlOut_last_value_end WHEN stateControl_2 = '0' ELSE
      ctrlOut_end_1;

  c_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        ctrlOut_last_value_valid <= '0';
      ELSIF enb_gated = '1' THEN
        ctrlOut_last_value_valid <= ctrlOut_valid_2;
      END IF;
    END IF;
  END PROCESS c_2_process;


  
  ctrlOut_valid_2 <= ctrlOut_last_value_valid WHEN stateControl_2 = '0' ELSE
      ctrlOut_valid_1;

  addr <= std_logic_vector(addr_bypass);

  writeEn <= writeEn_2;

  ctrlOut_start <= ctrlOut_start_2;

  ctrlOut_end <= ctrlOut_end_2;

  ctrlOut_valid <= ctrlOut_valid_2;

END rtl;

