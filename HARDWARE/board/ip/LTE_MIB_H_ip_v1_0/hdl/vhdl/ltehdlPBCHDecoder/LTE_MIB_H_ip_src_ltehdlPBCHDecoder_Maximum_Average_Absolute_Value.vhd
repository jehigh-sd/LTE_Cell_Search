-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlPBCHDecoder\LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Maximum_Average_Absolute_Value.vhd
-- Created: 2022-05-23 17:26:45
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Maximum_Average_Absolute_Value
-- Source Path: ltehdlPBCHDecoder/BCH Decoder/softBitScalingUnit/Maximum Average Absolute Value
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.LTE_MIB_H_ip_src_ltehdlPBCHDecoder_ltehdlPBCHDecoder_pac.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Maximum_Average_Absolute_Value IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        dataIn_0                          :   IN    std_logic_vector(19 DOWNTO 0);  -- ufix20
        dataIn_1                          :   IN    std_logic_vector(19 DOWNTO 0);  -- ufix20
        dataIn_2                          :   IN    std_logic_vector(19 DOWNTO 0);  -- ufix20
        ctrlIn_start                      :   IN    std_logic;
        ctrlIn_end                        :   IN    std_logic;
        ctrlIn_valid                      :   IN    std_logic;
        maxOut                            :   OUT   std_logic_vector(18 DOWNTO 0);  -- ufix19_En17
        maxValid                          :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Maximum_Average_Absolute_Value;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlPBCHDecoder_Maximum_Average_Absolute_Value IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL dataIn                           : vector_of_signed20(0 TO 2);  -- sfix20_En17 [3]
  SIGNAL maxOut_1                         : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL maxValid_1                       : std_logic;
  SIGNAL regs_absVals                     : vector_of_unsigned19(0 TO 2);  -- ufix19_En17 [3]
  SIGNAL regs_sumAbs                      : unsigned(20 DOWNTO 0);  -- ufix21_En17
  SIGNAL regs_averageFull                 : unsigned(37 DOWNTO 0);  -- ufix38_En35
  SIGNAL regs_average                     : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL regs_maxAverage                  : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL regs_startPipe                   : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_validPipe                   : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_endPipe                     : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_not_empty                   : std_logic;
  SIGNAL regs_absVals_next                : vector_of_unsigned19(0 TO 2);  -- ufix19_En17 [3]
  SIGNAL regs_sumAbs_next                 : unsigned(20 DOWNTO 0);  -- ufix21_En17
  SIGNAL regs_averageFull_next            : unsigned(37 DOWNTO 0);  -- ufix38_En35
  SIGNAL regs_average_next                : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL regs_maxAverage_next             : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL regs_startPipe_next              : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_validPipe_next              : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_endPipe_next                : std_logic_vector(0 TO 4);  -- boolean [5]
  SIGNAL regs_not_empty_next              : std_logic;
  SIGNAL maxOut_bypass                    : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL maxOut_last_value                : unsigned(18 DOWNTO 0);  -- ufix19_En17
  SIGNAL maxValid_2                       : std_logic;
  SIGNAL maxValid_last_value              : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  dataIn(0) <= signed(dataIn_0);
  dataIn(1) <= signed(dataIn_1);
  dataIn(2) <= signed(dataIn_2);

  Maximum_Average_Absolute_Value_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        regs_not_empty <= '0';
      ELSIF enb_gated = '1' THEN
        regs_absVals <= regs_absVals_next;
        regs_sumAbs <= regs_sumAbs_next;
        regs_averageFull <= regs_averageFull_next;
        regs_average <= regs_average_next;
        regs_maxAverage <= regs_maxAverage_next;
        regs_startPipe <= regs_startPipe_next;
        regs_validPipe <= regs_validPipe_next;
        regs_endPipe <= regs_endPipe_next;
        regs_not_empty <= regs_not_empty_next;
      END IF;
    END IF;
  END PROCESS Maximum_Average_Absolute_Value_process;

  Maximum_Average_Absolute_Value_output : PROCESS (ctrlIn_end, ctrlIn_start, ctrlIn_valid, dataIn, regs_absVals, regs_average,
       regs_averageFull, regs_endPipe, regs_maxAverage, regs_not_empty,
       regs_startPipe, regs_sumAbs, regs_validPipe)
    VARIABLE next_absVals : vector_of_unsigned19(0 TO 2);
    VARIABLE next_sumAbs : unsigned(20 DOWNTO 0);
    VARIABLE next_startPipe : std_logic_vector(0 TO 4);
    VARIABLE next_validPipe : std_logic_vector(0 TO 4);
    VARIABLE next_endPipe : std_logic_vector(0 TO 4);
    VARIABLE t0_absVals : vector_of_unsigned19(0 TO 2);
    VARIABLE t0_startPipe : std_logic_vector(0 TO 4);
    VARIABLE t0_validPipe : std_logic_vector(0 TO 4);
    VARIABLE t0_endPipe : std_logic_vector(0 TO 4);
    VARIABLE regs_absVals_temp : vector_of_unsigned19(0 TO 2);
    VARIABLE regs_sumAbs_temp : unsigned(20 DOWNTO 0);
    VARIABLE regs_averageFull_temp : unsigned(37 DOWNTO 0);
    VARIABLE regs_average_temp : unsigned(18 DOWNTO 0);
    VARIABLE regs_maxAverage_temp : unsigned(18 DOWNTO 0);
    VARIABLE regs_startPipe_temp : std_logic_vector(0 TO 4);
    VARIABLE regs_validPipe_temp : std_logic_vector(0 TO 4);
    VARIABLE regs_endPipe_temp : std_logic_vector(0 TO 4);
    VARIABLE regs_absvals_temp_0 : vector_of_unsigned19(0 TO 2);
    VARIABLE regs_startpipe_temp_0 : std_logic_vector(0 TO 4);
    VARIABLE regs_validpipe_temp_0 : std_logic_vector(0 TO 4);
    VARIABLE regs_endpipe_temp_0 : std_logic_vector(0 TO 4);
    VARIABLE slice_temp : signed(19 DOWNTO 0);
    VARIABLE cast : vector_of_signed21(0 TO 2);
    VARIABLE cast_0 : vector_of_signed21(0 TO 2);
    VARIABLE add_cast : vector_of_unsigned22(0 TO 1);
    VARIABLE add_cast_0 : vector_of_unsigned22(0 TO 1);
    VARIABLE add_temp : vector_of_unsigned22(0 TO 1);
  BEGIN
    slice_temp := to_signed(16#00000#, 20);
    regs_absVals_temp := regs_absVals;
    regs_sumAbs_temp := regs_sumAbs;
    regs_averageFull_temp := regs_averageFull;
    regs_average_temp := regs_average;
    regs_maxAverage_temp := regs_maxAverage;
    regs_startPipe_temp := regs_startPipe;
    regs_validPipe_temp := regs_validPipe;
    regs_endPipe_temp := regs_endPipe;
    regs_not_empty_next <= regs_not_empty;
    -- Calculate the average absolute value of each 3 element input vector,
    -- and then compute the maximum result within the incoming packet.
    -- The start, end and valid samples of the packet are indicated by the
    -- corresponding elements of the ctrlIn signal.
    IF ( NOT regs_not_empty) = '1' THEN 
      regs_absvals_temp_0 := (OTHERS => to_unsigned(16#00000#, 19));
      regs_startpipe_temp_0 := (OTHERS => '0');
      regs_validpipe_temp_0 := (OTHERS => '0');
      regs_endpipe_temp_0 := (OTHERS => '0');
      t0_absVals := regs_absvals_temp_0;
      t0_startPipe := regs_startpipe_temp_0;
      t0_validPipe := regs_validpipe_temp_0;
      t0_endPipe := regs_endpipe_temp_0;
      regs_absVals_temp := t0_absVals;
      regs_sumAbs_temp := to_unsigned(16#000000#, 21);
      regs_averageFull_temp := to_unsigned(0, 38);
      regs_average_temp := to_unsigned(16#00000#, 19);
      regs_maxAverage_temp := to_unsigned(16#00000#, 19);
      regs_startPipe_temp := t0_startPipe;
      regs_validPipe_temp := t0_validPipe;
      regs_endPipe_temp := t0_endPipe;
      regs_not_empty_next <= '1';
    END IF;
    --------------------------------------------------------------------------
    -- Assign outputs
    --------------------------------------------------------------------------
    maxValid_1 <= regs_endPipe_temp(4);
    --------------------------------------------------------------------------
    -- Compute next register values.
    --------------------------------------------------------------------------
    regs_maxAverage_next <= regs_maxAverage_temp;
    -- Udate control logic pipelines
    next_startPipe(0) := ctrlIn_start;
    next_validPipe(0) := ctrlIn_valid;
    next_endPipe(0) := ctrlIn_end;
    next_startPipe(1 TO 4) := regs_startPipe_temp(0 TO 3);
    next_validPipe(1 TO 4) := regs_validPipe_temp(0 TO 3);
    next_endPipe(1 TO 4) := regs_endPipe_temp(0 TO 3);

    FOR k IN 0 TO 2 LOOP
      IF dataIn(k) < to_signed(16#00000#, 20) THEN 
        cast(k) := resize(dataIn(k), 21);
        cast_0(k) :=  - (cast(k));
        IF (cast_0(k)(20) = '0') AND (cast_0(k)(19) /= '0') THEN 
          slice_temp := X"7FFFF";
        ELSIF (cast_0(k)(20) = '1') AND (cast_0(k)(19) /= '1') THEN 
          slice_temp := X"80000";
        ELSE 
          slice_temp := cast_0(k)(19 DOWNTO 0);
        END IF;
      ELSE 
        slice_temp := dataIn(k);
      END IF;
      next_absVals(k) := unsigned(slice_temp(18 DOWNTO 0));
    END LOOP;

    next_sumAbs := resize(regs_absVals_temp(0), 21);

    FOR k_0 IN 0 TO 1 LOOP
      add_cast(k_0) := resize(next_sumAbs, 22);
      add_cast_0(k_0) := resize(regs_absVals_temp(k_0 + 1), 22);
      add_temp(k_0) := add_cast(k_0) + add_cast_0(k_0);
      next_sumAbs := add_temp(k_0)(20 DOWNTO 0);
    END LOOP;

    regs_averageFull_next <= regs_sumAbs_temp * to_unsigned(16#15555#, 17);
    IF (regs_averageFull_temp(37) /= '0') OR (regs_averageFull_temp(36 DOWNTO 18) = "1111111111111111111") THEN 
      regs_average_next <= "1111111111111111111";
    ELSE 
      regs_average_next <= regs_averageFull_temp(36 DOWNTO 18) + ('0' & regs_averageFull_temp(17));
    END IF;
    IF regs_validPipe_temp(3) = '1' THEN 
      IF regs_startPipe_temp(3) = '1' THEN 
        regs_maxAverage_next <= regs_average_temp;
      ELSIF regs_average_temp > regs_maxAverage_temp THEN 
        regs_maxAverage_next <= regs_average_temp;
      END IF;
    END IF;
    --------------------------------------------------------------------------
    -- Write new values to registers.
    --------------------------------------------------------------------------
    regs_absVals_next <= next_absVals;
    regs_startPipe_next <= next_startPipe;
    regs_validPipe_next <= next_validPipe;
    regs_endPipe_next <= next_endPipe;
    maxOut_1 <= regs_maxAverage_temp;
    regs_sumAbs_next <= next_sumAbs;
  END PROCESS Maximum_Average_Absolute_Value_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        maxOut_last_value <= to_unsigned(16#00000#, 19);
      ELSIF enb_gated = '1' THEN
        maxOut_last_value <= maxOut_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  maxOut_bypass <= maxOut_last_value WHEN stateControl_2 = '0' ELSE
      maxOut_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        maxValid_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        maxValid_last_value <= maxValid_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  maxValid_2 <= maxValid_last_value WHEN stateControl_2 = '0' ELSE
      maxValid_1;

  maxOut <= std_logic_vector(maxOut_bypass);

  maxValid <= maxValid_2;

END rtl;

