-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlDownlinkSyncDemod\LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Determine_Frame_Timing.vhd
-- Created: 2022-05-23 17:26:44
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Determine_Frame_Timing
-- Source Path: ltehdlDownlinkSyncDemod/Sync Signal Search/SSS Searcher/Determine Frame Timing
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Determine_Frame_Timing IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enable                            :   IN    std_logic;
        PSSTimingOffset                   :   IN    std_logic_vector(14 DOWNTO 0);  -- ufix15
        TDD                               :   IN    std_logic;
        halfFrameIndicator                :   IN    std_logic;
        SSSPSSPhaseAligned                :   IN    std_logic;
        timingOffset                      :   OUT   std_logic_vector(14 DOWNTO 0)  -- ufix15
        );
END LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Determine_Frame_Timing;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Determine_Frame_Timing IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in2_unsigned                     : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL timingOffset_1                   : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL timingOffsetReg                  : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL timingOffsetReg_next             : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL timingOffset_bypass              : unsigned(14 DOWNTO 0);  -- ufix15
  SIGNAL timingOffset_last_value          : unsigned(14 DOWNTO 0);  -- ufix15

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  in2_unsigned <= unsigned(PSSTimingOffset);

  Determine_Frame_Timing_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        timingOffsetReg <= to_unsigned(16#0000#, 15);
      ELSIF enb_gated = '1' THEN
        timingOffsetReg <= timingOffsetReg_next;
      END IF;
    END IF;
  END PROCESS Determine_Frame_Timing_process;

  Determine_Frame_Timing_output : PROCESS (SSSPSSPhaseAligned, TDD, enable, halfFrameIndicator, in2_unsigned, reset,
       timingOffsetReg)
    VARIABLE halfFrameOffsetNeeded : std_logic;
    VARIABLE toff : signed(15 DOWNTO 0);
    VARIABLE toff_0 : signed(15 DOWNTO 0);
    VARIABLE sub_temp : signed(17 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(17 DOWNTO 0);
  BEGIN
    halfFrameOffsetNeeded := '0';
    toff_0 := to_signed(16#0000#, 16);
    sub_temp := to_signed(16#00000#, 18);
    sub_temp_0 := to_signed(16#00000#, 18);
    toff := to_signed(16#0000#, 16);
    timingOffsetReg_next <= timingOffsetReg;
    ----------------------------------------------------------------------------
    -- Constants
    ----------------------------------------------------------------------------
    -- length of cyclic prefix 0
    -- length of cyclic prefixes 1 to 6
    -- length of useful part of OFDM symbol
    ----------------------------------------------------------------------------
    -- Registers
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    -- Assign output
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    -- Compute timing offset and update register
    ----------------------------------------------------------------------------
    IF reset = '1' THEN 
      timingOffsetReg_next <= to_unsigned(16#0000#, 15);
    ELSIF enable = '1' THEN 
      -- A half frame offset is needed if either halfFrameIndicator==true
      -- or SSSPSSPhaseAligned==true, but not if both are true or false.
      -- This results in an xnor.
      IF halfFrameIndicator = SSSPSSPhaseAligned THEN 
        halfFrameOffsetNeeded := '1';
      ELSE 
        halfFrameOffsetNeeded := '0';
      END IF;
      toff := signed(resize(in2_unsigned, 16));
      IF TDD = '1' THEN 
        sub_temp_0 := resize(resize(toff, 17) + to_signed(16#00001#, 17), 18) - to_signed(16#0091C#, 18);
        toff_0 := sub_temp_0(15 DOWNTO 0);
      ELSE 
        sub_temp := resize(resize(toff, 17) + to_signed(16#00001#, 17), 18) - to_signed(16#003C0#, 18);
        toff_0 := sub_temp(15 DOWNTO 0);
      END IF;
      IF halfFrameOffsetNeeded = '1' THEN 
        toff_0 := toff_0 - to_signed(16#2580#, 16);
      END IF;
      IF toff_0 < to_signed(16#0000#, 16) THEN 
        -- Wrap if the result is below zero.
        toff_0 := toff_0 + to_signed(16#4B00#, 16);
      END IF;
      timingOffsetReg_next <= unsigned(toff_0(14 DOWNTO 0));
    END IF;
    timingOffset_1 <= timingOffsetReg;
  END PROCESS Determine_Frame_Timing_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        timingOffset_last_value <= to_unsigned(16#0000#, 15);
      ELSIF enb_gated = '1' THEN
        timingOffset_last_value <= timingOffset_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  timingOffset_bypass <= timingOffset_last_value WHEN stateControl_2 = '0' ELSE
      timingOffset_1;

  timingOffset <= std_logic_vector(timingOffset_bypass);

END rtl;

