-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlDownlinkSyncDemod\LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_StreamSyncronizer.vhd
-- Created: 2022-05-23 17:26:44
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_StreamSyncronizer
-- Source Path: ltehdlDownlinkSyncDemod/Sync Signal Search/PSS Searcher/Correlators/StreamSyncronizer
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_ltehdlDownlinkSyncDemod_pac.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_StreamSyncronizer IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        pop                               :   IN    std_logic;
        dataIn                            :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30
        push                              :   IN    std_logic;
        dataOut                           :   OUT   std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        validOut                          :   OUT   std_logic
        );
END LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_StreamSyncronizer;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_StreamSyncronizer IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL in1_unsigned                     : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL dataOut_1                        : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL validOut_1                       : std_logic;
  SIGNAL wrAddr                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL rdAddr                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL dataOutReg                       : unsigned(29 DOWNTO 0);  -- ufix30
  SIGNAL validOutReg                      : std_logic;
  SIGNAL mem                              : vector_of_unsigned30(0 TO 3);  -- ufix30 [4]
  SIGNAL level                            : signed(15 DOWNTO 0);  -- int16
  SIGNAL wrAddr_next                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL rdAddr_next                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL dataOutReg_next                  : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL validOutReg_next                 : std_logic;
  SIGNAL mem_next                         : vector_of_unsigned30(0 TO 3);  -- ufix30_En24 [4]
  SIGNAL level_next                       : signed(15 DOWNTO 0);  -- int16
  SIGNAL dataOut_bypass                   : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL dataOut_last_value               : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL validOut_2                       : std_logic;
  SIGNAL validOut_last_value              : std_logic;

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  in1_unsigned <= unsigned(dataIn);

  StreamSyncronizer_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        wrAddr <= to_unsigned(16#0#, 2);
        rdAddr <= to_unsigned(16#0#, 2);
        dataOutReg <= to_unsigned(16#00000000#, 30);
        validOutReg <= '0';
        mem <= (OTHERS => to_unsigned(16#00000000#, 30));
        level <= to_signed(16#0000#, 16);
      ELSIF enb_gated = '1' THEN
        wrAddr <= wrAddr_next;
        rdAddr <= rdAddr_next;
        dataOutReg <= dataOutReg_next;
        validOutReg <= validOutReg_next;
        mem <= mem_next;
        level <= level_next;
      END IF;
    END IF;
  END PROCESS StreamSyncronizer_process;

  StreamSyncronizer_output : PROCESS (dataOutReg, in1_unsigned, level, mem, pop, push, rdAddr, validOutReg, wrAddr)
    VARIABLE level_temp : signed(15 DOWNTO 0);
    VARIABLE sub_temp : signed(16 DOWNTO 0);
    VARIABLE add_temp : signed(16 DOWNTO 0);
  BEGIN
    sub_temp := to_signed(16#00000#, 17);
    add_temp := to_signed(16#00000#, 17);
    level_temp := level;
    wrAddr_next <= wrAddr;
    rdAddr_next <= rdAddr;
    dataOutReg_next <= dataOutReg;
    mem_next <= mem;
    --------------------------------------------------------------------------
    -- Constants
    --------------------------------------------------------------------------
    -- Persistent variable initialization
    --------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- Outputs
    --------------------------------------------------------------------------
    --------------------------------------------------------------------------
    -- Calculate next state values
    --------------------------------------------------------------------------
    IF pop = '1' THEN 
      dataOutReg_next <= mem(to_integer(rdAddr));
      rdAddr_next <= rdAddr + to_unsigned(16#1#, 2);
      sub_temp := resize(level, 17) - to_signed(16#00001#, 17);
      IF (sub_temp(16) = '0') AND (sub_temp(15) /= '0') THEN 
        level_temp := X"7FFF";
      ELSIF (sub_temp(16) = '1') AND (sub_temp(15) /= '1') THEN 
        level_temp := X"8000";
      ELSE 
        level_temp := sub_temp(15 DOWNTO 0);
      END IF;
    END IF;
    IF push = '1' THEN 
      mem_next(to_integer(wrAddr)) <= in1_unsigned;
      wrAddr_next <= wrAddr + to_unsigned(16#1#, 2);
      add_temp := resize(level_temp, 17) + to_signed(16#00001#, 17);
      IF (add_temp(16) = '0') AND (add_temp(15) /= '0') THEN 
        level_temp := X"7FFF";
      ELSIF (add_temp(16) = '1') AND (add_temp(15) /= '1') THEN 
        level_temp := X"8000";
      ELSE 
        level_temp := add_temp(15 DOWNTO 0);
      END IF;
    END IF;
    validOutReg_next <= pop;
    dataOut_1 <= dataOutReg;
    validOut_1 <= validOutReg;
    level_next <= level_temp;
  END PROCESS StreamSyncronizer_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        dataOut_last_value <= to_unsigned(16#00000000#, 30);
      ELSIF enb_gated = '1' THEN
        dataOut_last_value <= dataOut_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  dataOut_bypass <= dataOut_last_value WHEN stateControl_2 = '0' ELSE
      dataOut_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        validOut_last_value <= '0';
      ELSIF enb_gated = '1' THEN
        validOut_last_value <= validOut_2;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  validOut_2 <= validOut_last_value WHEN stateControl_2 = '0' ELSE
      validOut_1;

  dataOut <= std_logic_vector(dataOut_bypass);

  validOut <= validOut_2;

END rtl;

