-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\zynqRadioHWSWLTEMIBDetectorRFSoC2x2\ltehdlDownlinkSyncDemod\LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Max_Element.vhd
-- Created: 2022-05-23 17:26:44
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Max_Element
-- Source Path: ltehdlDownlinkSyncDemod/Sync Signal Search/PSS Searcher/Max Peak Searcher/Max Element
-- Hierarchy Level: 6
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_ltehdlDownlinkSyncDemod_pac.ALL;

ENTITY LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Max_Element IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb                               :   IN    std_logic;
        x_0                               :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30
        x_1                               :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30
        x_2                               :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30
        xmax                              :   OUT   std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        idx                               :   OUT   std_logic_vector(1 DOWNTO 0)  -- ufix2
        );
END LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Max_Element;


ARCHITECTURE rtl OF LTE_MIB_H_ip_src_ltehdlDownlinkSyncDemod_Max_Element IS

  -- Signals
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 41);  -- ufix1 [42]
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL x                                : vector_of_unsigned30(0 TO 2);  -- ufix30_En24 [3]
  SIGNAL xmax_1                           : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL idx_1                            : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL valReg                           : unsigned(29 DOWNTO 0);  -- ufix30
  SIGNAL x3Reg                            : unsigned(29 DOWNTO 0);  -- ufix30
  SIGNAL idxReg                           : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL valReg_next                      : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL x3Reg_next                       : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL idxReg_next                      : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL xmax_bypass                      : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL xmax_last_value                  : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL idx_bypass                       : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL idx_last_value                   : unsigned(1 DOWNTO 0);  -- ufix2

BEGIN
  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_reg(0) <= stateControl_1;
        delayMatch_reg(1 TO 41) <= delayMatch_reg(0 TO 40);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  stateControl_2 <= delayMatch_reg(41);

  enb_gated <= stateControl_2 AND enb;

  x(0) <= unsigned(x_0);
  x(1) <= unsigned(x_1);
  x(2) <= unsigned(x_2);

  Max_Element_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        valReg <= to_unsigned(16#00000000#, 30);
        x3Reg <= to_unsigned(16#00000000#, 30);
        idxReg <= to_unsigned(16#0#, 2);
      ELSIF enb_gated = '1' THEN
        valReg <= valReg_next;
        x3Reg <= x3Reg_next;
        idxReg <= idxReg_next;
      END IF;
    END IF;
  END PROCESS Max_Element_process;

  Max_Element_output : PROCESS (idxReg, valReg, x, x3Reg)
  BEGIN
    valReg_next <= valReg;
    idxReg_next <= idxReg;
    -- Returns the maximum value in the vector x. x must be of length 3.
    -- This requires two comparisons. To optimize for HDL timing performance,
    -- a single register is placed between the two comparisons.
    -- Has a delay of 1 sample.
    -- max value out of 1 and 2
    -- register for 3rd input
    -- zero based index
    -- second comparison
    IF valReg > x3Reg THEN 
      xmax_1 <= valReg;
      idx_1 <= idxReg;
    ELSE 
      xmax_1 <= x3Reg;
      idx_1 <= to_unsigned(16#2#, 2);
    END IF;
    -- first comparison
    IF x(0) > x(1) THEN 
      valReg_next <= x(0);
      idxReg_next <= to_unsigned(16#0#, 2);
    ELSE 
      valReg_next <= x(1);
      idxReg_next <= to_unsigned(16#1#, 2);
    END IF;
    x3Reg_next <= x(2);
  END PROCESS Max_Element_output;


  out0_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        xmax_last_value <= to_unsigned(16#00000000#, 30);
      ELSIF enb_gated = '1' THEN
        xmax_last_value <= xmax_bypass;
      END IF;
    END IF;
  END PROCESS out0_bypass_process;


  
  xmax_bypass <= xmax_last_value WHEN stateControl_2 = '0' ELSE
      xmax_1;

  out1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        idx_last_value <= to_unsigned(16#0#, 2);
      ELSIF enb_gated = '1' THEN
        idx_last_value <= idx_bypass;
      END IF;
    END IF;
  END PROCESS out1_bypass_process;


  
  idx_bypass <= idx_last_value WHEN stateControl_2 = '0' ELSE
      idx_1;

  xmax <= std_logic_vector(xmax_bypass);

  idx <= std_logic_vector(idx_bypass);

END rtl;

